#!/usr/bin/env python3

"""
AppHide: Hide applications from the gnome shell
Copyright (C) 2016 William Forde

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

############

Dependencies
PyXDG => Python library to access freedesktop.org standards => https://freedesktop.org/wiki/Software/pyxdg/
PyGObject => Development files for the pygobject bindings => https://wiki.gnome.org/action/show/Projects/PyGObject

# Ubuntu
python3-gi
python3-xdg

# ArchLinux
python-xdg
pygobject-devel
"""

# Standard library imports
import configparser
import logging
import hashlib
import shutil
import sys
import gi
import os

# XDG Package imports
import xdg.Exceptions
import xdg.DesktopEntry
import xdg.BaseDirectory

# Import Gtk 3.0 Specifically
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk
from gi.repository import Gio
from gi.repository import Pango

# Constants
__name__ = "AppHide"
__icon__ = "application-default-icon"

# Logging
logger = logging.getLogger("apphide")
logger.setLevel(logging.DEBUG)
consoleHandler = logging.StreamHandler(sys.stdout)
consoleHandler.setLevel(logging.DEBUG)
logger.addHandler(consoleHandler)


class AppHideApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="org.apphide", flags=Gio.ApplicationFlags.FLAGS_NONE)
        self.window = None

    def do_activate(self):
        if not self.window:
            self.window = AppHideWin(application=self, title="AppHide")
            self.window.connect("delete-event", self.on_quit)
            self.window.show_all()
        self.window.present()

    def on_quit(self, action, param):
        if self.window.row_changed:
            self.info_dialog()
        self.quit()

    def info_dialog(self):
        """ Display a error dialog when unable to hide/unhide an application """
        dialog = Gtk.MessageDialog(self.window, 0, Gtk.MessageType.INFO, Gtk.ButtonsType.OK, "Action Required")
        dialog.format_secondary_text("You may need to logout and login again for change to take effect")
        dialog.run()
        dialog.destroy()


class AppHideWin(Gtk.ApplicationWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.current_desktop = os.environ.get("XDG_CURRENT_DESKTOP")
        self.set_default_icon_name(__icon__)
        self.set_default_size(860, 800)
        self.filter_by = None

        # Scrolledwindow to scroll through all applications
        scrolledwindow = Gtk.ScrolledWindow()
        scrolledwindow.set_hexpand(False)
        scrolledwindow.set_vexpand(True)
        scrolledwindow.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        self.add(scrolledwindow)

        # Outer box to store the filter box and listbox
        outer_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        outer_box.set_halign(Gtk.Align.CENTER)
        outer_box.set_valign(Gtk.Align.START)
        outer_box.set_size_request(860, -1)
        outer_box.set_margin_right(16)
        outer_box.set_margin_left(16)
        scrolledwindow.add(outer_box)

        # Listbox to list all applications
        self.listbox = Gtk.ListBox()
        self.listbox.connect("row-activated", self.on_row_activated)
        self.listbox.set_selection_mode(Gtk.SelectionMode.NONE)
        outer_box.pack_end(self.listbox, True, True, 0)

        # Fetch list of all applications and sort by name
        xdg_apps = self.get_xdg_apps()
        xdg_apps = sorted(xdg_apps, key=lambda data: data.name.lower())

        # Add all found applications to the listbox
        for xdg_app in xdg_apps:
            row = ListBoxRowApp()
            row.btn_hide.connect("clicked", self.on_hide_clicked, row, xdg_app)
            row.set_icon(xdg_app.getIcon())
            row.set_name(xdg_app.name)
            row.set_description(xdg_app.getComment())
            if xdg_app.getNoDisplay():
                row.hidden = True
            self.listbox.add(row)

        # Install filter to filter resutls to all / Hidden / UnHidden
        self.listbox.set_filter_func(self.filter_listbox, None, False)
        self.listbox.set_header_func(self.header_func, None)
        self.listbox.show_all()

        # Filter box to store the filter radio button
        filter_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        filter_box.set_halign(Gtk.Align.CENTER)
        filter_box.set_valign(Gtk.Align.START)
        outer_box.pack_start(filter_box, True, True, 0)

        # All Radio Button
        btn_filter_all = Gtk.RadioButton.new_with_label_from_widget(None, "All")
        btn_filter_all.connect("toggled", self.on_radio_toggled, None)
        btn_filter_all.set_tooltip_text("Show all applications")
        filter_box.pack_start(btn_filter_all, False, False, 0)

        # Hidden Radio Button
        btn_filter_hidden = Gtk.RadioButton.new_with_label_from_widget(btn_filter_all, "Hidden")
        btn_filter_hidden.connect("toggled", self.on_radio_toggled, "Hidden")
        btn_filter_hidden.set_tooltip_text("Show only hidden applications")
        filter_box.pack_start(btn_filter_hidden, False, False, 0)

        # UnHidden Radio Button
        btn_filter_unhidden = Gtk.RadioButton.new_with_label_from_widget(btn_filter_all, "UnHidden")
        btn_filter_unhidden.connect("toggled", self.on_radio_toggled, "UnHidden")
        btn_filter_unhidden.set_tooltip_text("Show only unhidden applications")
        filter_box.pack_start(btn_filter_unhidden, False, False, 0)
        self.row_changed = False

    @staticmethod
    def header_func(row, before, user_data):
        existing_header = row.get_header()
        if existing_header:
            if before:
                existing_header.show()
            else:
                existing_header.hide()
        elif before:
            separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
            row.set_header(separator)

    def on_radio_toggled(self, _, filter_by):
        if not self.filter_by == filter_by:
            self.filter_by = filter_by
            self.listbox.invalidate_filter()
            self.listbox.invalidate_headers()

    def filter_listbox(self, row, data, notify_destroy):
        if self.filter_by is None:
            return True
        elif self.filter_by == "Hidden":
            return row.hidden
        else:
            return not row.hidden

    def get_xdg_apps(self):
        """ Scan the Application directory for valid desktop entries.
            Return the xdg app if desktop entry is an application and
            is allowed to be shown on current desktop
        """

        # Fetch list of all application directorys and sort in order of preference
        app_dirs = [os.path.join(data_dir, "applications") for data_dir in xdg.BaseDirectory.xdg_data_dirs[1:]]
        app_dirs.reverse()

        # Fetch set of all desktop files from all application folders
        desktop_files = dict()
        for app_dir in app_dirs:
            # Skip if directory does not exist
            if not os.path.exists(app_dir):
                continue

            # Find all .desktop files within applications folder
            for filename in os.listdir(app_dir):
                if filename.endswith(".desktop") and not filename == "apphide.desktop":
                    filepath = os.path.join(app_dir, filename)
                    desktop_files[filename] = filepath

        # Loop each application directory and load in the desktop files
        for filename, filepath in desktop_files.items():
            # Create xdg object
            xdg_file = get_xdg_data(filepath)

            # Check if application is not already set to NoDisplay
            # Check that the application is allowd on the current desktop
            if xdg_file and not xdg_file.getNoDisplay() and xdg_file.getType() == "Application" \
                    and self.show_on_desktop(xdg_file):
                logger.debug("Loaded desktop entry: %s", filename)
                yield AppManager(xdg_file, filename, filepath)

    def show_on_desktop(self, xdg_file):
        """ Check if the given application is allowed to be shown on current destop """
        # Check if this desktop is not one of the restricted desktops
        if self.current_desktop in xdg_file.getNotShowIn():
            return False

        # Check if this desktop is one of the desktops where it is specifically allowed to be shown
        elif xdg_file.getOnlyShowIn() and self.current_desktop not in xdg_file.getOnlyShowIn():
            return False

        # Application must be allowed to be shown then
        else:
            return True

    def error_dialog(self, error_msg, text):
        """ Display a error dialog when unable to hide/unhide an application """
        dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.ERROR, Gtk.ButtonsType.CANCEL, error_msg)
        dialog.format_secondary_text(text)
        dialog.run()
        dialog.destroy()

    def on_hide_clicked(self, button, row, xdg_file):
        # Set label of button to Hide/UnHide, depending on active state
        active = button.get_active()
        try:
            xdg_file.hide_app(active)
        except (EnvironmentError, configparser.Error) as e:
            button.set_active(not active)
            self.error_dialog("Failed to %s %s" % ("Hide" if active else "UnHide", xdg_file.name), str(e))
        else:
            text = "UnHide" if active else "Hide"
            button.set_label(text)
            button.set_tooltip_text("%s application" % text)
            self.row_changed = True
            row.changed()

    @staticmethod
    def on_row_activated(_, row):
        row.hidden = not row.hidden


class AppManager(object):
    """ Mannager to handle the hiding and unhiding of desktop applications """
    APP_DIR = xdg.BaseDirectory.save_data_path("applications")
    DATA_DIR = xdg.BaseDirectory.save_config_path(__name__.lower(), "tracker")

    def __init__(self, xdg_file, filename, filepath):
        self._name = self._icon = self._description = None
        self.local_app = os.path.join(self.APP_DIR, filename)
        self.tracked = os.path.join(self.DATA_DIR, filename)
        self.source_path = filepath
        self.xdg_file_org = xdg_file

        # Load desktop file data from local file if found
        if os.path.exists(self.local_app):
            local_xdg_file = get_xdg_data(self.local_app)
            if local_xdg_file:
                self.xdg_file = local_xdg_file
            else:
                self.xdg_file = xdg_file
        else:
            self.xdg_file = xdg_file

    def __getattr__(self, name):
        return getattr(self.xdg_file, name)

    @property
    def name(self):
        """  """
        if self._name:
            return self._name
        else:
            return self.getName()

    def hide_app(self, state):
        """ Hide or unhide an application by add NoDisplay to .desktop file and set to True or False """
        if self.xdg_file.getNoDisplay() == state:
            return True

        log_state = "Hiding application: %s" if state else "UnHiding application: %s"
        logger.info(log_state, self.name)

        # Check that local file exists before check if it was modified
        if os.path.exists(self.local_app):
            # Check if local file was modidied sense it was created and modify inplace if so
            modify_inplace = self.modified()
        else:
            modify_inplace = False

        # Change desktop file if needed
        if modify_inplace is True or state is True:
            try:
                self.change_state("NoDisplay", state, modify_inplace=modify_inplace)
            except EnvironmentError as e:
                logger.error("Failed to change NoDisplay option for reson: %s", e.strerror)
                raise
            except configparser.Error as e:
                logger.error("Failed to parse desktop file: %s", str(e))
                raise
            else:
                self.xdg_file = get_xdg_data(self.local_app)
                return True
        else:
            logger.info("Removing desktop file: %s", self.local_app)
            try:
                os.remove(self.local_app)
            except EnvironmentError as e:
                logger.error("Failed to remove local desktop file for reaseon: %s", e.strerror)
                logger.error(self.local_app)
                raise
            else:
                self.xdg_file = self.xdg_file_org
                return True

    def change_state(self, key, value, modify_inplace=False):
        """ Change or create config file option

            key: string - The config option to change or create
            value: any - The value for the config option
            modify_inplace: boolean - Change the file inplace or create from source desktop file
        """

        # Initialize configparser, change optionxform to str instead of lower case
        app_data = configparser.ConfigParser()
        app_data.optionxform = str

        # Read in the source desktop file or local file depending on modify_inplace value
        app_data.read(self.local_app if modify_inplace else self.source_path)
        entry = app_data["Desktop Entry"]

        # Check if desktop file needs to be changed
        if not (key in entry and entry.getboolean(key) == value):
            # Set or change the config option
            entry[key] = str(value).lower()

            # Save the changed config to disk
            if modify_inplace:
                self.file_modifiy(app_data)
            else:
                self.file_create(app_data)

    def file_create(self, app_data):
        # Create tracked file and copy to local file
        logger.info("Creating tracker file: %s", self.tracked)
        self.secure_write(app_data, self.tracked)

        # Make copy of tracked file
        try:
            logger.info("Creating desktop file: %s", self.local_app)
            shutil.copyfile(self.tracked, self.local_app)
        except:
            self.safe_file_remove(self.tracked)
            raise

    def file_modifiy(self, app_data):
        logger.info("Updating desktop file: %s", self.local_app)
        # Replace the local file directly
        tmp_local_app = self.local_app + ".tmp"
        self.secure_write(app_data, tmp_local_app)

        # Move temp file into place
        try:
            os.remove(self.local_app)
            os.rename(tmp_local_app, self.local_app)
        except:
            self.safe_file_remove(tmp_local_app)
            raise

    def secure_write(self, app_data, filepath):
        """ Write out the app data to file, but if file write fails then
            it will catch the error and remove the bad file if exists
        """
        try:
            with open(filepath, "w") as stream:
                app_data.write(stream)
        except:
            self.safe_file_remove(filepath)
            raise

    def modified(self):
        """ Return True if file was modified sence it was created else False if not
            Will also remove the tracked file so it can be replaced later
        """

        # If tracked file was not found then return True as is imposable to detected if file was modified
        if not os.path.exists(self.tracked):
            logger.debug("Tracked file does not exist, Assuming local desktop file was modified")
            logger.debug(self.tracked)
            return True
        else:
            try:
                # Return True if the hash of the tracked and local file does not match
                modified = not self.file_hash(self.tracked) == self.file_hash(self.local_app)
            except EnvironmentError as e:
                logger.error("Failed to calculate hash of tracked or local file: %s", e.strerror)
                logger.error(self.tracked)
                logger.error(self.local_app)
                logger.error("Assuming local desktop file was modified")
                return True
            else:
                msg = "modified" if modified else "unmodified"
                logger.debug("Local desktop file was %s sence creation", msg)
            finally:
                logger.info("Removing tracked file: %s", self.tracked)
                self.safe_file_remove(self.tracked)

    @staticmethod
    def file_hash(filepath):
        """ Check the hash of a givin file """
        hasher = hashlib.sha224()

        # Read in file and update the hasher
        with open(filepath, "rb") as stream:
            hasher.update(stream.read())

        # Return a sha224 hash of the file
        return hasher.hexdigest()

    @staticmethod
    def safe_file_remove(filepath):
        """ Safely remove a file from disk and suppresses any error that may occur """
        try:
            os.remove(filepath)
        except OSError as e:
            logger.error("Failed to remove file: %s", filepath)
            logger.error("Reason: %s", e.strerror)


class ListBoxRowApp(Gtk.ListBoxRow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        iner_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        iner_box.set_margin_top(16)
        iner_box.set_margin_bottom(16)
        self.add(iner_box)

        # Icon
        self._app_icon = Gtk.Image()
        self._app_icon.set_pixel_size(64)
        self._app_icon.set_valign(Gtk.Align.CENTER)
        self._app_icon.set_halign(Gtk.Align.START)
        iner_box.pack_start(self._app_icon, True, True, 16)

        # Name
        self._app_name = WrapedLabel()
        self._app_name.set_size_request(165, -1)
        self._app_name.set_max_width_chars(20)
        iner_box.pack_start(self._app_name, True, True, 0)

        # Description
        self._app_description = WrapedLabel()
        self._app_description.set_size_request(400, -1)
        self._app_description.set_max_width_chars(50)
        self._app_description.set_margin_left(16)
        iner_box.pack_start(self._app_description, True, True, 16)

        # Button
        self.btn_hide = Gtk.ToggleButton("Hide")
        self.btn_hide.set_size_request(100, -1)
        self.btn_hide.set_halign(Gtk.Align.END)
        self.btn_hide.set_valign(Gtk.Align.CENTER)
        self.btn_hide.set_tooltip_text("Hide application")
        iner_box.pack_start(self.btn_hide, True, True, 24)

    def set_name(self, name):
        """ Set the name of application """
        self._app_name.set_label(name)

    def set_icon(self, icon):
        """ Set the Icon of the application """
        self._app_icon.set_from_icon_name(icon, Gtk.IconSize.DIALOG)

    def set_description(self, description):
        """ Set the description of the application """
        self._app_description.set_label(description)

    @property
    def hidden(self):
        """ Return True/False if the row is hidden or not """
        return self.btn_hide.get_active()

    @hidden.setter
    def hidden(self, value):
        """ Set the state of the toggle button """
        self.btn_hide.set_active(value)


class WrapedLabel(Gtk.Label):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Set line count to 3 and enable line wrap
        self.set_lines(3)
        self.set_line_wrap(True)

        # Set line wrap to work-char and ensure that it cuts out at the end of the third line
        self.set_line_wrap_mode(Pango.WrapMode.WORD_CHAR)
        self.set_ellipsize(Pango.EllipsizeMode.END)

        # Align text to left side of widget
        self.set_xalign(0.0)

        # Align text box to top and to the left
        self.set_valign(Gtk.Align.START)
        self.set_halign(Gtk.Align.START)


def get_xdg_data(fullpath):
    try:
        return xdg.DesktopEntry.DesktopEntry(fullpath)
    except xdg.Exceptions.ParsingError as e:
        logger.error("Failed to Parse XDG file: %s", e.file)
        logger.error(e.msg)
    except xdg.Exceptions.ValidationError as e:
        logger.error("Failed to Validate XDG file:", e.file)
        logger.error(e.msg)
    except xdg.Exceptions.Error as e:
        logger.error("Unexpected xdg error")
        logger.error(e.msg)

app = AppHideApp()
exit_status = app.run(None)
sys.exit(exit_status)
